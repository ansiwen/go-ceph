// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package cutil

import "unsafe"

// The following code needs some explanation:
// This creates slices on top of the C memory buffers allocated before in
// order to safely and comfortably use them as arrays. First the void pointer
// is cast to a pointer to an array of the type that will be stored in the
// array. Because the size of an array is a constant, but the real array size
// is dynamic, we just use the biggest possible index value maxIdx, to make
// sure it's always big enough. (Nothing is allocated by casting, so the size
// can be arbitrarily big.) So, if the array should store items of myType, the
// cast would be (*[maxIdx]myItem)(myCMemPtr).
// From that array pointer a slice is created with the [start:end:capacity]
// syntax. The capacity must be set explicitly here, because by default it
// would be set to the size of the original array, which is maxIdx, which
// doesn't reflect reality in this case. This results in definitions like:
// cSlice := (*[maxIdx]myItem)(myCMemPtr)[:numOfItems:numOfItems]

// CPtrSize is the size of CPtr
const CPtrSize = CSize(unsafe.Sizeof(*(*CPtr)(nil)))

// CPtrCSlice is a C allocated slice of pointers.
type CPtrCSlice []CPtr

// NewCPtrCSlice returns a CPtrCSlice.
// Similar to CString it must be freed with Free(slice)
func NewCPtrCSlice(size int) CPtrCSlice {
	if size == 0 {
		return nil
	}
	cMem := cMalloc(CSize(size) * CPtrSize)
	cSlice := (*[maxIdx]CPtr)(cMem)[:size:size]
	return cSlice
}

// Ptr returns a pointer to CPtrCSlice
func (v *CPtrCSlice) Ptr() CPtr {
	if len(*v) == 0 {
		return nil
	}
	return CPtr(&(*v)[0])
}

// Free frees a CPtrCSlice
func (v *CPtrCSlice) Free() {
	cFree(unsafe.Pointer(v.Ptr()))
	*v = nil
}

// The following code needs some explanation:
// This creates slices on top of the C memory buffers allocated before in
// order to safely and comfortably use them as arrays. First the void pointer
// is cast to a pointer to an array of the type that will be stored in the
// array. Because the size of an array is a constant, but the real array size
// is dynamic, we just use the biggest possible index value maxIdx, to make
// sure it's always big enough. (Nothing is allocated by casting, so the size
// can be arbitrarily big.) So, if the array should store items of myType, the
// cast would be (*[maxIdx]myItem)(myCMemPtr).
// From that array pointer a slice is created with the [start:end:capacity]
// syntax. The capacity must be set explicitly here, because by default it
// would be set to the size of the original array, which is maxIdx, which
// doesn't reflect reality in this case. This results in definitions like:
// cSlice := (*[maxIdx]myItem)(myCMemPtr)[:numOfItems:numOfItems]

// CSizeSize is the size of CSize
const CSizeSize = CSize(unsafe.Sizeof(*(*CSize)(nil)))

// CSizeCSlice is a C allocated slice of pointers.
type CSizeCSlice []CSize

// NewCSizeCSlice returns a CSizeCSlice.
// Similar to CString it must be freed with Free(slice)
func NewCSizeCSlice(size int) CSizeCSlice {
	if size == 0 {
		return nil
	}
	cMem := cMalloc(CSize(size) * CSizeSize)
	cSlice := (*[maxIdx]CSize)(cMem)[:size:size]
	return cSlice
}

// Ptr returns a pointer to CSizeCSlice
func (v *CSizeCSlice) Ptr() CPtr {
	if len(*v) == 0 {
		return nil
	}
	return CPtr(&(*v)[0])
}

// Free frees a CSizeCSlice
func (v *CSizeCSlice) Free() {
	cFree(unsafe.Pointer(v.Ptr()))
	*v = nil
}
